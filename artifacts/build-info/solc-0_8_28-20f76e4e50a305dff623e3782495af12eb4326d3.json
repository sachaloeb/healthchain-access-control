{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-20f76e4e50a305dff623e3782495af12eb4326d3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Counter.sol": "project/contracts/Counter.sol",
    "contracts/DataSharing.sol": "project/contracts/DataSharing.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Counter.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Counter {\n  uint public x;\n\n  event Increment(uint by);\n\n  function inc() public {\n    x++;\n    emit Increment(1);\n  }\n\n  function incBy(uint by) public {\n    require(by > 0, \"incBy: increment should be positive\");\n    x += by;\n    emit Increment(by);\n  }\n}\n"
      },
      "project/contracts/DataSharing.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @notice Minimal interface to interact with your ConsentManager contract\ninterface IConsentManager {\n    function hasValidConsent(\n        address patient,\n        address requester,\n        uint256 dataTypeId,\n        uint256 atTime\n    ) external view returns (bool);\n}\n\n/**\n * @title DataSharing\n * @notice Stores hashes + URIs for off-chain medical data and enforces access via ConsentManager.\n *\n * Design goals (from project spec):\n *  - Only hashes and references on-chain, never raw medical data.\n *  - Access is allowed only if ConsentManager reports valid consent.\n *  - Every access attempt (granted or denied) is logged as an event.\n */\ncontract DataSharing {\n    /// @notice Single off-chain data record for a patient & data type\n    struct DataRecord {\n        bytes32 recordHash;   // Hash of the off-chain record\n        string storageURI;    // Pointer (e.g., IPFS CID, HTTPS URL, etc.)\n        uint256 createdAt;    // Timestamp when record was registered\n    }\n\n    /// @notice Consent manager used to verify access permissions\n    IConsentManager public consentManager;\n\n    /// @notice Simple owner pattern so you can update config if needed\n    address public owner;\n\n    /// @dev patient => dataTypeId => list of records\n    mapping(address => mapping(uint256 => DataRecord[])) private records;\n\n    /// @notice Emitted whenever a patient registers a new data record\n    event DataRecordRegistered(\n        address indexed patient,\n        uint256 indexed dataTypeId,\n        bytes32 indexed recordHash,\n        string storageURI,\n        uint256 timestamp\n    );\n\n    /// @notice Emitted when access is granted\n    event AccessGranted(\n        address indexed patient,\n        address indexed requester,\n        uint256 indexed dataTypeId,\n        string storageURI,\n        uint256 timestamp\n    );\n\n    /// @notice Emitted when access is denied\n    event AccessDenied(\n        address indexed patient,\n        address indexed requester,\n        uint256 indexed dataTypeId,\n        string reason,\n        uint256 timestamp\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not contract owner\");\n        _;\n    }\n\n    constructor(address _consentManager) {\n        require(_consentManager != address(0), \"Invalid consent manager\");\n        consentManager = IConsentManager(_consentManager);\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Register a new off-chain data record.\n     * @dev Patient-centric model: only the patient can register their own records.\n     */\n    function registerDataRecord(\n        address patient,\n        uint256 dataTypeId,\n        bytes32 recordHash,\n        string calldata storageURI\n    ) external {\n        require(msg.sender == patient, \"Only patient can register\");\n        require(dataTypeId != 0, \"Invalid dataTypeId\");\n        require(recordHash != bytes32(0), \"Empty record hash\");\n        require(bytes(storageURI).length > 0, \"Empty storage URI\");\n\n        DataRecord memory rec = DataRecord({\n            recordHash: recordHash,\n            storageURI: storageURI,\n            createdAt: block.timestamp\n        });\n\n        records[patient][dataTypeId].push(rec);\n\n        emit DataRecordRegistered(\n            patient,\n            dataTypeId,\n            recordHash,\n            storageURI,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice View helper to get the latest record for a patient & data type.\n     */\n    function getLatestRecord(\n        address patient,\n        uint256 dataTypeId\n    ) public view returns (DataRecord memory) {\n        DataRecord[] storage list = records[patient][dataTypeId];\n        require(list.length > 0, \"No records for this data type\");\n        return list[list.length - 1];\n    }\n\n    /**\n     * @notice Returns how many records exist for a patient & data type.\n     */\n    function getRecordCount(\n        address patient,\n        uint256 dataTypeId\n    ) external view returns (uint256) {\n        return records[patient][dataTypeId].length;\n    }\n\n    /**\n     * @notice Request access to patient's latest record for a given data type.\n     * @dev\n     *  - Checks ConsentManager.hasValidConsent(patient, msg.sender, dataTypeId, now).\n     *  - Emits AccessGranted or AccessDenied for the audit log.\n     *  - Returns the storage URI on success (off-chain system uses it to fetch data).\n     */\n    function accessData(\n        address patient,\n        uint256 dataTypeId\n    ) external returns (string memory storageURI) {\n        bool ok = consentManager.hasValidConsent(\n            patient,\n            msg.sender,\n            dataTypeId,\n            block.timestamp\n        );\n\n        if (!ok) {\n            emit AccessDenied(\n                patient,\n                msg.sender,\n                dataTypeId,\n                \"No valid consent\",\n                block.timestamp\n            );\n            revert(\"No valid consent\");\n        }\n\n        DataRecord memory latest = getLatestRecord(patient, dataTypeId);\n\n        emit AccessGranted(\n            patient,\n            msg.sender,\n            dataTypeId,\n            latest.storageURI,\n            block.timestamp\n        );\n\n        return latest.storageURI;\n    }\n\n    /**\n     * @notice Optional helper: update the ConsentManager address.\n     *         Handy during development if you redeploy ConsentManager.\n     */\n    function setConsentManager(address _consentManager) external onlyOwner {\n        require(_consentManager != address(0), \"Invalid consent manager\");\n        consentManager = IConsentManager(_consentManager);\n    }\n}"
      }
    }
  }
}